package tscfg

import java.io.{PrintWriter, Writer}
import java.util.Date

import com.typesafe.config.{ConfigFactory, Config, ConfigRenderOptions, ConfigValue}

import scala.collection.JavaConversions._
import scala.collection.mutable


object generator {
  val version = ConfigFactory.load().getString("tscfg.version")

  val defaultPackageName = "tscfg.example"
  val defaultClassName   = "ExampleCfg"

  /**
    * Generation options
    * @param packageName  package name
    * @param className    class name
    * @param j7           true to generate for Typesafe Config v &lt;= 1.2.1
    * @param preamble     preamble to include in generated code
    */
  case class GenOpts(packageName: String = defaultPackageName,
                     className: String   = defaultClassName,
                     j7: Boolean         = false,
                     preamble: Option[String] = None
                    )
  /**
    * Generates java code for the given configuration spec.
    *
    * @param config       spec
    * @param out          code is written here
    * @param genOpts      generation options
    */
  def java(config: Config, out: Writer)
          (implicit genOpts: GenOpts): Unit = {

    createAllNodes(config)

    val pw = out match {
      case w: PrintWriter => w
      case w => new PrintWriter(w)
    }
    genJava(Node.root, pw)
  }

  // we first traverse the list of elements to build a tree representation.

  sealed abstract class Node {
    val key: Key
  }

  case class LeafNode(key: Key, value: ConfigValue)(implicit genOpts: GenOpts) extends Node {
    val accessor = Accessor.parseValueSpec(value.unwrapped().toString)
  }

  case class BranchNode(key: Key) extends Node {
    val map: mutable.Map[String,Node] = mutable.Map()

    def put(simpleKey: String, node: Node): Unit = {
      map.put(simpleKey, node)
    }
  }

  object Node {
    val root = BranchNode(Key.root)
  }


  object nodes {
    val nodeMap = mutable.HashMap[Key, Node]()

    put(Key.root, Node.root)

    // creates a leaf node
    def createLeaf(key: Key, value: ConfigValue)(implicit genOpts: GenOpts): LeafNode = nodeMap.get(key) match {
      case None =>
        val node = LeafNode(key, value)
        put(key, node)
        node

      case Some(node) => throw new Error(s"Node by key=$key already created")
    }

    // creates a branch node
    def createBranch(key: Key): BranchNode = nodeMap.get(key) match {
      case None =>
        val node = BranchNode(key)
        put(key, node)
        node

      case Some(node) if node.isInstanceOf[BranchNode] => node.asInstanceOf[BranchNode]
      case Some(node) => throw new Error(s"LeafNode by key=$key already created")
    }

    private def put(key: Key, node: Node) = {
      //println(s"nodeMap PUT: $key -> $node")
      require(!nodeMap.contains(key))
      nodeMap.put(key, node)
    }
  }

  private def createAllNodes(conf: Config)(implicit genOpts: GenOpts): Unit = {
    conf.entrySet() foreach { e =>
      val key = Key(e.getKey)
      val value = e.getValue
      val leafNode = nodes.createLeaf(key, value)
      createAncestorsOf(key, leafNode)
    }
  }

  private def createAncestorsOf(childKey: Key, childNode: Node): Unit = {
    createParent(childKey.parent, childNode)

    def createParent(parentKey: Key, child: Node): Unit = {
      val parentNode = nodes.createBranch(parentKey)
      parentNode.put(child.key.simple, child)

      if (parentNode.key != Key.root)
        createParent(parentKey.parent, parentNode)
    }
  }

  private def showNode(node: Node, indentIncr:String = "\t", simpleKey: Boolean = true): Unit = {
    show(node)

    def show(n: Node, indent: String = ""): Unit = {
      val label = if (simpleKey) n.key.simple else n.key.toString

      n match {
        case LeafNode(key, value) =>
          println(s"$indent$label = ${value.render()}")

        case n: BranchNode =>
          println(s"$indent$label")
          n.map.keys.toList.sorted foreach { key =>
            show(n.map(key), indent + indentIncr)
          }
      }
    }
  }

  private def genJava(node: Node, out: PrintWriter)
                     (implicit genOpts: GenOpts): Unit = {

    out.println(s"// auto-generated by tscfg $version on ${new Date()}")
    genOpts.preamble foreach { p =>
      out.println(s"// ${p.replace("\n", "\n// ")}\n")
    }
    out.println(s"package ${genOpts.packageName};\n")
    out.println(s"import com.typesafe.config.Config;\n")

    gen(node)

    def gen(n: Node, indent: String = ""): Unit = {
      val simple = n.key.simple
      val isRoot = simple == "/"
      val symbol = if (simple == "/") genOpts.className else simple

      val javaId = javaIdentifier(symbol)

      n match {
        case ln: LeafNode  => genForLeaf(ln)
        case n: BranchNode => genForBranch(n)
      }

      def genForLeaf(ln: LeafNode): Unit = {
        out.println(s"${indent}public final ${ln.accessor.javaType} $javaId;")
      }

      def genForBranch(bn: BranchNode): Unit = {
        val className = upperFirst(symbol)

        if (!isRoot) {
          // declare symbol:
          out.println(s"${indent}public final $className $javaId;")
        }

        // <class>

        val classDecl = if (isRoot) "class" else "static class"
        out.println(s"${indent}public $classDecl $className {")

        val orderedNames = bn.map.keys.toList.sorted

        // generate for members:
        orderedNames foreach { name => gen(bn.map(name), indent + "  ") }

        // <constructor>
        out.println(s"$indent  public $className(Config c) {")
        orderedNames foreach { name =>
          out.print(s"$indent    this.${javaIdentifier(name)} = ")
          bn.map(name) match {
            case ln@LeafNode(k, v) =>
              val path = k.simple
              val instance = ln.accessor.instance(path)
              val comment = v.render(ConfigRenderOptions.concise())
              out.println(s"""$instance; // $comment""")

            case BranchNode(k)  =>
              val className = upperFirst(k.simple)
              out.println(s"""new $className(c.getConfig("${k.simple}"));""")
          }
        }
        out.println(s"$indent  }")
        // </constructor>

        // toString():
        out.println(s"""$indent  public String toString() { return toString(""); }""")

        // <toString(String i)>
        out.println(s"$indent  public String toString(String i) {")
        val ids = orderedNames map { name =>
          val id = javaIdentifier(name)

          bn.map(name) match {
            case ln@LeafNode(k, v) =>
              (if(ln.accessor.javaType == "String") {
                s"""i+ "$id = " + (this.$id == null ? null : '"' + this.$id + '"')"""
              }
              else {
                s"""i+ "$id = " + this.$id"""
              }) + s""" + "\\n""""

            case BranchNode(k) =>
              s"""i+ "$id {\\n" + this.$id.toString(i+"    ") +i+ "}\\n""""
          }
        }
        out.println(s"$indent  return ${ids.mkString("\n" +indent + "        +")};")
        out.println(s"$indent  }")
        // </toString(String i)>

        out.println(s"$indent}")
        // </class>
      }
    }
  }

  /**
    * Returns a valid Java identifier from the give symbol:
    *
    * - appends a '_' in case the symbol is a java keyword or special literal ("null", "true", "false");
    * - otherwise, returns the given symbol if already a valid java identifier;
    * - otherwise, prefixes the symbol with '_' if first character is valid but not at first position, and
    *   replaces any character that cannot be part of a java identifier with '_'.
    */
  def javaIdentifier(symbol: String): String = {
    if (javaKeywords.contains(symbol)) symbol + "_"
    else if (isJavaIdentifier(symbol)) symbol else {
      val c0 = symbol.charAt(0)
      val first: String = if (Character.isJavaIdentifierStart(c0)) String.valueOf(c0)
      else if (Character.isJavaIdentifierPart(c0)) "_" + c0 else "_"
      val rest = symbol.substring(1) map { c =>
        if (Character.isJavaIdentifierPart(c)) c else '_'
      }
      first + rest
    }
  }

  private def isJavaIdentifier(symbol: String): Boolean = {
    Character.isJavaIdentifierStart(symbol.charAt(0)) &&
      symbol.substring(1).forall(Character.isJavaIdentifierPart)
  }

  private def upperFirst(symbol:String) = symbol.charAt(0).toUpper + symbol.substring(1)

  /**
    * Set of java keywords plus the literals "null", "true", "false".
    * (from Sect 3.9 of the Java Language Spec, Java SE 8 Edition)
    */
  val javaKeywords: List[String] = List(
    "abstract", "continue", "for",        "new",       "switch",
    "assert",   "default",  "if",         "package",   "synchronized",
    "boolean",  "do",       "goto",       "private",   "this",
    "break",    "double",   "implements", "protected", "throw",
    "byte",     "else",     "import",     "public",    "throws",
    "case",     "enum",     "instanceof", "return",    "transient",
    "catch",    "extends",  "int",        "short",     "try",
    "char",     "final",    "interface",  "static",    "void",
    "class",    "finally",  "long",       "strictfp",  "volatile",
    "const",    "float",    "native",     "super",     "while",

    "null",     "true",     "false"
  )
}
